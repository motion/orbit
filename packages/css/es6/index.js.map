{"version":3,"sources":["../src/index.js"],"names":["motionStyle","COLOR_KEYS","TRANSFORM_KEYS_MAP","x","y","z","dropShadow","COMMA_JOINED","boxShadow","transition","SHORTHANDS","borderLeftRadius","borderRightRadius","borderBottomRadius","borderTopRadius","FALSE_VALUES","background","backgroundColor","borderColor","BORDER_KEY","border","borderLeft","borderRight","borderBottom","borderTop","px","test","options","isColor","color","toColor","OBJECT_TRANSFORM","textShadow","blur","v","inset","spread","image","position","join","repeat","processArrayItem","key","val","level","Array","isArray","processArray","value","length","push","map","objectValue","arrayOrObject","arr","obj","GRADIENT","linearGradient","object","all","deg","from","to","radialGradient","processObject","toReturn","subKey","hasOwnProperty","processStyles","styles","opts","shouldSnake","snakeCase","valueType","finalKey","respond","firstChar","has","indexOf","isSpecific","index","top","right","bottom","left","console","log","k","Error","errorMessage","helpers","hash","snakeToCamel","camelToSnake"],"mappings":"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","file":"index.js","sourcesContent":["// @flow\nimport {\n  colorToString,\n  isColorLike,\n  snakeToCamel,\n  camelToSnake,\n  hash,\n} from './helpers'\nimport type { Color } from './types'\nimport { CAMEL_TO_SNAKE } from './cssNameMap'\n\n// exports\nexport type { Transform, Color } from './types'\nexport * from './helpers'\n\nconst COLOR_KEYS = new Set(['color', 'backgroundColor', 'borderColor'])\nconst TRANSFORM_KEYS_MAP = {\n  x: 'translateX',\n  y: 'translateY',\n  z: 'translateZ',\n  dropShadow: 'drop-shadow',\n}\n\nconst COMMA_JOINED = {\n  boxShadow: true,\n  transition: true,\n}\n\nconst SHORTHANDS = {\n  borderLeftRadius: ['borderTopLeftRadius', 'borderBottomLeftRadius'],\n  borderRightRadius: ['borderTopRightRadius', 'borderBottomRightRadius'],\n  borderBottomRadius: ['borderBottomLeftRadius', 'borderBottomRightRadius'],\n  borderTopRadius: ['borderTopRightRadius', 'borderTopLeftRadius'],\n}\n\nconst FALSE_VALUES = {\n  background: 'transparent',\n  backgroundColor: 'transparent',\n  borderColor: 'transparent',\n}\n\nconst BORDER_KEY = {\n  border: true,\n  borderLeft: true,\n  borderRight: true,\n  borderBottom: true,\n  borderTop: true,\n}\n\n// helpers\nconst px = (x: number | string) => (/px$/.test(`${x}`) ? x : `${x}px`)\n\n// style transform creator\nexport default function motionStyle(options: Object = {}) {\n  const isColor = (color: any) => isColorLike(color, options)\n  const toColor = (color: Color) => colorToString(color, options)\n\n  const OBJECT_TRANSFORM = {\n    textShadow: ({ x, y, blur, color }) =>\n      `${px(x)} ${px(y)} ${px(blur)} ${toColor(color)}`,\n    boxShadow: v =>\n      v.inset || v.x || v.y || v.blur || v.spread || v.color\n        ? `${v.inset ? 'inset' : ''} ${px(v.x)} ${px(v.y)} ${px(v.blur)} ${px(\n            v.spread,\n          )} ${toColor(v.color)}`\n        : toColor(v),\n    background: v =>\n      isColor(v)\n        ? toColor(v)\n        : `${toColor(v.color)} ${v.image || ''} ${(v.position\n            ? v.position.join(' ')\n            : v.position) || ''} ${v.repeat || ''}`,\n  }\n\n  function processArrayItem(key: string, val: any, level: number = 0) {\n    // recurse\n    if (isColor(val)) {\n      return toColor(val)\n    }\n    if (Array.isArray(val)) {\n      return processArray(key, val, level + 1)\n    }\n    return typeof val === 'number' ? `${val}px` : val\n  }\n\n  function processArray(\n    key: string,\n    value: Array<number | string>,\n    level: number = 0,\n  ): string {\n    if (key === 'background') {\n      if (isColor(value)) {\n        return toColor(value)\n      }\n    }\n    // solid default option for borders\n    if (BORDER_KEY[key] && value.length === 2) {\n      value.push('solid')\n    }\n    return value\n      .map(val => processArrayItem(key, val))\n      .join(level === 0 && COMMA_JOINED[key] ? ', ' : ' ')\n  }\n\n  function objectValue(key: string, value: any) {\n    if (Array.isArray(value)) {\n      return processArray(key, value)\n    }\n    if (OBJECT_TRANSFORM[key]) {\n      return OBJECT_TRANSFORM[key](value)\n    }\n    if (\n      key === 'scale' ||\n      key === 'scaleX' ||\n      key === 'scaleY' ||\n      key === 'grayscale' ||\n      key === 'brightness'\n    ) {\n      return value\n    }\n    if (typeof value === 'number') {\n      return `${value}px`\n    }\n    return value\n  }\n\n  const arrayOrObject = (arr, obj) => val =>\n    Array.isArray(val) ? arr(val) : obj(val)\n\n  const GRADIENT = {\n    linearGradient: (key, object) =>\n      `linear-gradient(${arrayOrObject(\n        all => processArray(key, all),\n        ({ deg, from, to }) =>\n          `${deg || 0}deg, ${from || 'transparent'}, ${to || 'transparent'}`,\n      )(object)})`,\n    radialGradient: processArray,\n  }\n\n  function processObject(key: string, object: Object): string {\n    if (\n      key === 'background' ||\n      key === 'color' ||\n      key === 'borderColor' ||\n      key === 'backgroundColor'\n    ) {\n      if (object.linearGradient) {\n        return GRADIENT.linearGradient(key, object.linearGradient)\n      }\n      if (object.radialGradient) {\n        return GRADIENT.radialGradient(key, object.radialGradient)\n      }\n      if (isColor(object)) {\n        return toColor(object)\n      }\n    }\n    const toReturn = []\n    for (const subKey in object) {\n      if (!object.hasOwnProperty(subKey)) {\n        continue\n      }\n      let value = object[subKey]\n      value = objectValue(subKey, value)\n      toReturn.push(`${TRANSFORM_KEYS_MAP[subKey] || subKey}(${value})`)\n    }\n    return toReturn.join(' ')\n  }\n\n  type Opts = {\n    errorMessage?: string,\n    snakeCase?: boolean,\n  }\n\n  // RETURN THIS\n  // style transformer\n  function processStyles(styles: Object, opts: Opts): Object {\n    const toReturn = {}\n    const shouldSnake = !opts || opts.snakeCase !== false\n    if (!styles || typeof styles !== 'object') {\n      return toReturn\n    }\n    for (let key of Object.keys(styles)) {\n      let value = styles[key]\n      let valueType = typeof value\n      let finalKey = key\n\n      // convert camel to snake\n      if (shouldSnake) {\n        finalKey = CAMEL_TO_SNAKE[key] || key\n      }\n\n      // get real values\n      if (valueType === false) {\n        value === FALSE_VALUES[key]\n        valueType = typeof value\n      }\n\n      // simple syles\n      if (valueType === 'undefined' || value === null || value === false) {\n        continue\n      }\n\n      let respond\n      const firstChar = key[0]\n\n      if (valueType === 'string' || valueType === 'number') {\n        toReturn[finalKey] = value\n        respond = true\n      } else if (COLOR_KEYS.has(key)) {\n        toReturn[finalKey] = toColor(value)\n        respond = true\n      } else if (Array.isArray(value)) {\n        if (key === 'fontFamily') {\n          toReturn[finalKey] = value\n            .map(x => (x.indexOf(' ') ? `\"${x}\"` : x))\n            .join(', ')\n        } else if (key === 'position') {\n          const isSpecific = value.length === 5\n          let index = 0\n          if (isSpecific) {\n            toReturn.position = value[0]\n            index++\n          } else {\n            toReturn.position = 'absolute'\n          }\n          toReturn.top = value[index++]\n          toReturn.right = value[index++]\n          toReturn.bottom = value[index++]\n          toReturn.left = value[index++]\n          console.log('to return', toReturn)\n        } else {\n          toReturn[finalKey] = processArray(key, value)\n        }\n        respond = true\n      } else if (\n        firstChar === '&' ||\n        firstChar === '@' ||\n        key === 'from' ||\n        key === 'to'\n      ) {\n        // recurse into psuedo or media query\n        toReturn[finalKey] = processStyles(value, opts)\n        respond = true\n      } else if (valueType === 'object') {\n        toReturn[finalKey] = processObject(key, value)\n        respond = true\n      } else if (key === 'isolate') {\n        toReturn[key] = value\n        respond = true\n      }\n\n      // shorthands\n      if (SHORTHANDS[key]) {\n        key = SHORTHANDS[key]\n        if (Array.isArray(key)) {\n          for (let k of key) {\n            k = shouldSnake ? CAMEL_TO_SNAKE[k] || k : k\n            toReturn[k] = value\n          }\n        }\n      }\n\n      if (respond) {\n        continue\n      }\n\n      throw new Error(\n        `${(opts && opts.errorMessage) ||\n          'Error'}: Invalid style value for ${key}: ${JSON.stringify(value)}`,\n      )\n    }\n\n    return toReturn\n  }\n\n  // expose helpers\n  processStyles.helpers = {\n    hash,\n    toColor,\n    isColor,\n    processArray,\n    processObject,\n    snakeToCamel,\n    camelToSnake,\n  }\n\n  return processStyles\n}\n"]}
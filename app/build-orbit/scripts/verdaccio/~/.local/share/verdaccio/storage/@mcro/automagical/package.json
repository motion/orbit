{
	"name": "@mcro/automagical",
	"versions": {
		"2.2.1": {
			"name": "@mcro/automagical",
			"main": "_/automagical.js",
			"version": "2.2.1",
			"scripts": {
				"build": "tsc || true",
				"watch": "tsc --watch --preserveWatchOutput"
			},
			"dependencies": {
				"@mcro/logger": "^2.2.1",
				"global": "^4.3.2"
			},
			"devDependencies": {
				"@types/webpack-env": "*"
			},
			"peerDependencies": {
				"mobx": "5.0.3"
			},
			"publishConfig": {
				"registry": "http://localhost:4343"
			},
			"readmeFilename": "README.md",
			"description": "Automagical is a light layer over Mobx that automatically turns classes into Mobx stores. As of Mobx 5 a lot of automagical was basically implemented in Mobx core under the `decorate` function and so it was simplified.",
			"_id": "@mcro/automagical@2.2.1",
			"_npmVersion": "6.3.0",
			"_nodeVersion": "9.11.2",
			"_npmUser": {},
			"dist": {
				"integrity": "sha512-dPNxv2ovQ/z+Bv0/1GWoqDufcIncEHYBo4bEf55L7+Whxyha6stCIwNuS77p/qdgxkeEca8/atKawyJ4W8GI3Q==",
				"shasum": "20d56ecb4dd75b2f413245bd430817c7f65823c0",
				"tarball": "http://localhost:4343/@mcro/automagical/-/@mcro/automagical-2.2.1.tgz"
			}
		}
	},
	"time": {
		"modified": "2018-08-08T17:54:59.445Z",
		"created": "2018-08-08T17:54:59.445Z",
		"2.2.1": "2018-08-08T17:54:59.445Z"
	},
	"dist-tags": {
		"latest": "2.2.1"
	},
	"_uplinks": {},
	"_distfiles": {},
	"_attachments": {
		"automagical-2.2.1.tgz": {
			"shasum": "20d56ecb4dd75b2f413245bd430817c7f65823c0",
			"version": "2.2.1"
		}
	},
	"_rev": "4-9d5c2d36d50a026b",
	"readme": "# automagical\n\nAutomagical is a light layer over Mobx that automatically turns classes into Mobx stores. As of Mobx 5 a lot of automagical was basically implemented in Mobx core under the `decorate` function and so it was simplified.\n\nWhat automagical does give you is the ability to really easily do reactions. Before in Mobx you'd have to do quite a bit to set up a well-structured reaction. Here's a contrived example:\n\n```js\nclass MyStore {\n  val = 0\n  val2 = 0\n\n  constructor() {\n    const dispose = Mobx.reaction(\n      () => this.val,\n      val => {\n        this.val2 = val + 1\n        // and if you want async stuff that cancels on next reaction, good luck...\n      },\n      {\n        // have to set this to get a nice log\n        name: `MyStore.reactToVal`,\n      },\n    )\n    // have to handle dispose manually each time\n    this.subscriptions.add({ dispose })\n  }\n}\n```\n\nWith automagical + react, you can do this:\n\n```js\nclass MyStore {\n  val = 0\n\n  // this will also log as MyStore.val2 automatically\n  val2 = react(\n    () => this.val,\n    // react() stores this value to the class property\n    val => val + 1,\n  )\n}\n```\n\nThis is nice, but pretty simple. It saves a lot of code though in the long run. But the real value comes with some of the features we've put together over time using react.\n\n### Asynchronous reactions\n\nThe second you want to do something asynchronous with Mobx you're forced to put together a variety of reptitive and brittle logic to track what's going on. With react you have a lot less to think about.\n\nFirst, you can just use async functions and it handles when they re-run automatically:\n\n```js\nclass MyStore {\n  val = react(\n    () => Mobx.now(2000),\n    async () => {\n      // if this takes longer than 2000, no worries, it will cancel and use the next fetch!\n      return await fetch('/something')\n    },\n  )\n}\n```\n\nWhat if you want to sleep a bit during typing?\n\n```js\nclass MyStore {\n  query = ''\n  answer = react(\n    () => this.query,\n    async (query, { sleep }) => {\n      // really nice debouncing\n      await sleep(100)\n      return await fetch(`/search?q=${query}`)\n    },\n  )\n}\n```\n\nOr wait for some things to be true?\n\n```js\nclass MyStore {\n  query = ''\n  serverResults = react(\n    () => this.query,\n    query => ({ query, answer: (await fetch(query)) })\n  )\n  localResults = react(\n    () => this.query,\n    query => ({ query, answer: (await someLocalQuery(query)) })\n  )\n  allResults = react(\n    () => this.query,\n    async (query, { when, sleep }) => {\n      await when(() => this.localResults.query === query)\n      await when(() => this.serverResults.query === query, 200)\n      await sleep(100)\n      return [...this.localResults.answer, ...this.serverResults.answer]\n    }\n  )\n}\n```\n\nInternally these helper functions throw a special value that is caught and handled properly. When the reaction re-runs it also ignores and throws after the last async function.\n\nYou can also do your own cancels. This will prevent the reaction from logging as a success, so you can debug just \"valid\" reactions, which is helpful as your app grows:\n\n```js\nclass MyStore {\n  val = react(\n    () => this.something,\n    () => {\n      // this wont log out\n      if (falsyCondition) {\n        throw react.cancel\n      }\n      return Math.random()\n    },\n  )\n}\n```\n\nThere is also a `whenChanged` helper which is like `when` but continues once the value changes at all.\n\n## Multiple updates\n\nFinally, you can multiple-updates, where you set a value multiple times over the course of a reaction:\n\n```js\nclass MyStore {\n  val = react(\n    () => this.someEvent,\n    async (_, { sleep, setValue }) => {\n      setValue('loading')\n      await sleep(100)\n      setValue('done loading')\n    },\n  )\n}\n```\n\nNote: you can't mix `setValue` and using `return` to return a value. Automagical will throw an error if it detects this.\n\nSimilarly, `getValue` exists which helps out when abstracting react functions. Otherwise you can get the current value usually by just referencing the variable name within the reaction.\n\n### todo\n\nDocument:\n\n- ReactionOptions\n  - delayValue\n  - onlyUpdateIfChanged"
}
{"ast":null,"code":"\"use strict\";\n\nvar _Object$keys = require(\"@babel/runtime-corejs2/core-js/object/keys\");\n\nvar _Array$isArray = require(\"@babel/runtime-corejs2/core-js/array/is-array\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = require(\"react\");\n\nexports.is = {\n  arr: _Array$isArray,\n  obj: function obj(a) {\n    return !!a && a.constructor.name === 'Object';\n  },\n  fun: function fun(a) {\n    return typeof a === 'function';\n  },\n  str: function str(a) {\n    return typeof a === 'string';\n  },\n  num: function num(a) {\n    return typeof a === 'number';\n  },\n  und: function und(a) {\n    return a === void 0;\n  },\n  boo: function boo(a) {\n    return typeof a === 'boolean';\n  }\n};\n/** An unsafe object/array/set iterator that allows for better minification */\n\nexports.each = function (obj, cb, ctx) {\n  if (exports.is.fun(obj.forEach)) {\n    obj.forEach(cb, ctx);\n  } else {\n    _Object$keys(obj).forEach(function (key) {\n      return cb.call(ctx, obj[key], key);\n    });\n  }\n};\n\nexports.toArray = function (a) {\n  return exports.is.und(a) ? [] : _Array$isArray(a) ? a : [a];\n};\n\nexports.useOnce = function (effect) {\n  return react_1.useEffect(effect, []);\n};\n\nexports.useForceUpdate = function () {\n  return react_1.useReducer(function () {\n    return {};\n  }, 0)[1];\n};\n/** Use a value from the previous render */\n\n\nfunction usePrev(value) {\n  var prevRef = react_1.useRef(undefined);\n  var prev = prevRef.current;\n  prevRef.current = value;\n  return prev;\n}\n\nexports.usePrev = usePrev;","map":{"version":3,"sources":["../src/helpers.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,IAAA,OAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;AASa,OAAA,CAAA,EAAA,GAAK;AAChB,EAAA,GAAG,gBADa;AAEhB,EAAA,GAAG,EAAE,aAAgB,CAAhB,EAAoB;AACvB,WAAA,CAAC,CAAC,CAAF,IAAO,CAAC,CAAC,WAAF,CAAc,IAAd,KAAuB,QAA9B;AAAsC,GAHxB;AAIhB,EAAA,GAAG,EAAE,aAAC,CAAD,EAAW;AAAoB,WAAA,OAAO,CAAP,KAAA,UAAA;AAAuB,GAJ3C;AAKhB,EAAA,GAAG,EAAE,aAAC,CAAD,EAAW;AAAkB,WAAA,OAAO,CAAP,KAAA,QAAA;AAAqB,GALvC;AAMhB,EAAA,GAAG,EAAE,aAAC,CAAD,EAAW;AAAkB,WAAA,OAAO,CAAP,KAAA,QAAA;AAAqB,GANvC;AAOhB,EAAA,GAAG,EAAE,aAAC,CAAD,EAAW;AAAqB,WAAA,CAAC,KAAK,KAAN,CAAA;AAAY,GAPjC;AAQhB,EAAA,GAAG,EAAE,aAAC,CAAD,EAAW;AAAmB,WAAA,OAAO,CAAP,KAAA,SAAA;AAAsB;AARzC,CAAL;AA+Bb;;AACa,OAAA,CAAA,IAAA,GAAe,UAAC,GAAD,EAAiB,EAAjB,EAA0B,GAA1B,EAAkC;AAC5D,MAAI,OAAA,CAAA,EAAA,CAAG,GAAH,CAAO,GAAG,CAAC,OAAX,CAAJ,EAAyB;AACvB,IAAA,GAAG,CAAC,OAAJ,CAAY,EAAZ,EAAgB,GAAhB;AACD,GAFD,MAEO;AACL,iBAAY,GAAZ,EAAiB,OAAjB,CAAyB,UAAA,GAAA,EAAG;AAAI,aAAA,EAAE,CAAC,IAAH,CAAQ,GAAR,EAAa,GAAG,CAAC,GAAD,CAAhB,EAAA,GAAA,CAAA;AAA2B,KAA3D;AACD;AACF,CANY;;AAQA,OAAA,CAAA,OAAA,GAAU,UAAI,CAAJ,EAAoB;AACzC,SAAA,OAAA,CAAA,EAAA,CAAG,GAAH,CAAO,CAAP,IAAY,EAAZ,GAAiB,eAAc,CAAd,IAAmB,CAAnB,GAAuB,CAAC,CAAD,CAAxC;AAA2C,CADhC;;AAGA,OAAA,CAAA,OAAA,GAAU,UAAC,MAAD,EAA6B;AAAK,SAAA,OAAA,CAAA,SAAA,CAAU,MAAV,EAAA,EAAA,CAAA;AAAqB,CAAjE;;AAEA,OAAA,CAAA,cAAA,GAAiB,YAAA;AAAM,SAAA,OAAA,CAAA,UAAA,CAAW,YAAA;AAAM,WAAA,EAAA;AAAI,GAArB,EAAuB,CAAvB,EAAA,CAAA,CAAA;AAA4C,CAAnE;AAEb;;;AACA,SAAgB,OAAhB,CAA2B,KAA3B,EAAmC;AACjC,MAAM,OAAO,GAAG,OAAA,CAAA,MAAA,CAAY,SAAZ,CAAhB;AACA,MAAM,IAAI,GAAG,OAAO,CAAC,OAArB;AACA,EAAA,OAAO,CAAC,OAAR,GAAkB,KAAlB;AACA,SAAO,IAAP;AACD;;AALD,OAAA,CAAA,OAAA,GAAA,OAAA","sourcesContent":["import { useEffect, useReducer, useRef } from 'react'\nimport { Indexable, OneOrMore } from './types'\n\ninterface IsArray {\n  <T>(a: T): a is T & readonly any[]\n}\n\ntype PlainObject<T> = Exclude<T & Indexable, Function | readonly any[]>\n\nexport const is = {\n  arr: Array.isArray as IsArray,\n  obj: <T extends any>(a: T): a is PlainObject<T> =>\n    !!a && a.constructor.name === 'Object',\n  fun: (a: unknown): a is Function => typeof a === 'function',\n  str: (a: unknown): a is string => typeof a === 'string',\n  num: (a: unknown): a is number => typeof a === 'number',\n  und: (a: unknown): a is undefined => a === void 0,\n  boo: (a: unknown): a is boolean => typeof a === 'boolean',\n}\n\ninterface EachFn {\n  <T = any, This = any>(\n    obj: ReadonlySet<T>,\n    cb: (this: This, value: T) => void,\n    ctx?: This\n  ): void\n\n  <T = any, This = any>(\n    arr: readonly T[],\n    cb: (this: This, value: T, index: number) => void,\n    ctx?: This\n  ): void\n\n  <T = any, This = any>(\n    obj: Indexable<T>,\n    cb: (this: This, value: T, key: string) => void,\n    ctx?: This\n  ): void\n}\n\n/** An unsafe object/array/set iterator that allows for better minification */\nexport const each: EachFn = (obj: Indexable, cb: any, ctx: any) => {\n  if (is.fun(obj.forEach)) {\n    obj.forEach(cb, ctx)\n  } else {\n    Object.keys(obj).forEach(key => cb.call(ctx, obj[key], key))\n  }\n}\n\nexport const toArray = <T>(a?: OneOrMore<T>): T[] =>\n  is.und(a) ? [] : Array.isArray(a) ? a : [a]\n\nexport const useOnce = (effect: React.EffectCallback) => useEffect(effect, [])\n\nexport const useForceUpdate = () => useReducer(() => ({}), 0)[1] as (() => void)\n\n/** Use a value from the previous render */\nexport function usePrev<T>(value: T): T | undefined {\n  const prevRef = useRef<any>(undefined)\n  const prev = prevRef.current\n  prevRef.current = value\n  return prev\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}
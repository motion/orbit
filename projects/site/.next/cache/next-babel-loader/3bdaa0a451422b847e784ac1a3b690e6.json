{"ast":null,"code":"\"use strict\";\n\nvar _Object$keys = require(\"@babel/runtime-corejs2/core-js/object/keys\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _Object$assign = require(\"@babel/runtime-corejs2/core-js/object/assign\");\n\nvar __assign = this && this.__assign || function () {\n  __assign = _Object$assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar createInterpolator_1 = require(\"./createInterpolator\");\n\nvar colorToRgba_1 = require(\"./colorToRgba\");\n\nvar tiny_invariant_1 = __importDefault(require(\"tiny-invariant\"));\n\nvar G = __importStar(require(\"./globals\")); // Problem: https://github.com/animatedjs/animated/pull/102\n// Solution: https://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly/658662\n\n\nvar numberRegex = /[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g; // Covers rgb, rgba, hsl, hsla\n// Taken from https://gist.github.com/olmokramer/82ccce673f86db7cda5e\n\nvar colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\\((-?\\d+%?[,\\s]+){2,3}\\s*[\\d\\.]+%?\\))/gi; // Covers color names (transparent, blue, etc.)\n\nvar colorNamesRegex; // rgba requires that the r,g,b are integers.... so we want to round them,\n// but we *dont* want to round the opacity (4th column).\n\nvar rgbaRegex = /rgba\\(([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+)\\)/gi;\n\nvar rgbaRound = function rgbaRound(_, p1, p2, p3, p4) {\n  return \"rgba(\" + Math.round(p1) + \", \" + Math.round(p2) + \", \" + Math.round(p3) + \", \" + p4 + \")\";\n};\n/**\n * Supports string shapes by extracting numbers so new values can be computed,\n * and recombines those values into new strings of the same shape.  Supports\n * things like:\n *\n *     \"rgba(123, 42, 99, 0.36)\"           // colors\n *     \"-45deg\"                            // values with units\n *     \"0 2px 2px 0px rgba(0, 0, 0, 0.12)\" // CSS box-shadows\n *     \"rotate(0deg) translate(2px, 3px)\"  // CSS transforms\n */\n\n\nexports.createStringInterpolator = function (config) {\n  if (!colorNamesRegex) colorNamesRegex = G.colorNames ? new RegExp(\"(\" + _Object$keys(G.colorNames).join('|') + \")\", 'g') : /^\\b$/; // never match\n  // Convert colors to rgba(...)\n\n  var output = config.output.map(function (value) {\n    return value.replace(colorRegex, colorToRgba_1.colorToRgba).replace(colorNamesRegex, colorToRgba_1.colorToRgba);\n  }); // Convert [\"1px 2px\", \"0px 0px\"] into [[1, 2], [0, 0]]\n\n  var keyframes = output.map(function (value) {\n    return value.match(numberRegex).map(Number);\n  }); // Convert [\"1px 2px\", \"0px 0px\"] into [[1, 0], [2, 0]]\n\n  var outputRanges = keyframes[0].map(function (_, i) {\n    return keyframes.map(function (values) {\n      tiny_invariant_1[\"default\"](i in values, 'The arity of each \"output\" value must be equal');\n      return values[i];\n    });\n  }); // Create an interpolator for each animated number\n\n  var interpolators = outputRanges.map(function (output) {\n    return createInterpolator_1.createInterpolator(__assign({}, config, {\n      output: output\n    }));\n  }); // Use the first `output` as a template for each call\n\n  return function (input) {\n    var i = 0;\n    return output[0].replace(numberRegex, function () {\n      return String(interpolators[i++](input));\n    }).replace(rgbaRegex, rgbaRound);\n  };\n};","map":{"version":3,"sources":["../src/stringInterpolation.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,oBAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;;AAEA,IAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,IAAA,gBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AACA,IAAA,CAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA,C,CAEA;AACA;;;AACA,IAAM,WAAW,GAAG,mDAApB,C,CAEA;AACA;;AACA,IAAM,UAAU,GAAG,0FAAnB,C,CAEA;;AACA,IAAI,eAAJ,C,CAEA;AACA;;AACA,IAAM,SAAS,GAAG,8DAAlB;;AACA,IAAM,SAAS,GAAG,SAAZ,SAAY,CAAC,CAAD,EAAS,EAAT,EAAqB,EAArB,EAAiC,EAAjC,EAA6C,EAA7C,EAAuD;AACvE,SAAA,UAAQ,IAAI,CAAC,KAAL,CAAW,EAAX,CAAR,GAAsB,IAAtB,GAA2B,IAAI,CAAC,KAAL,CAAW,EAAX,CAA3B,GAAyC,IAAzC,GAA8C,IAAI,CAAC,KAAL,CAAW,EAAX,CAA9C,GAA4D,IAA5D,GAAiE,EAAjE,GAAmE,GAAnE;AAAsE,CADxE;AAGA;;;;;;;;;;;;AAUa,OAAA,CAAA,wBAAA,GAA2B,UACtC,MADsC,EACJ;AAElC,MAAI,CAAC,eAAL,EACE,eAAe,GAAG,CAAC,CAAC,UAAF,GACd,IAAI,MAAJ,CAAW,MAAI,aAAY,CAAC,CAAC,UAAd,EAA0B,IAA1B,CAA+B,GAA/B,CAAJ,GAAuC,GAAlD,EAAuD,GAAvD,CADc,GAEd,MAFJ,CAHgC,CAKrB;AAEb;;AACA,MAAM,MAAM,GAAG,MAAM,CAAC,MAAP,CAAc,GAAd,CAAkB,UAAA,KAAA,EAAK;AACpC,WAAA,KAAK,CAAC,OAAN,CAAc,UAAd,EAA0B,aAAA,CAAA,WAA1B,EAAuC,OAAvC,CAA+C,eAA/C,EAAgE,aAAA,CAAA,WAAhE,CAAA;AAA4E,GAD/D,CAAf,CARkC,CAYlC;;AACA,MAAM,SAAS,GAAG,MAAM,CAAC,GAAP,CAAW,UAAA,KAAA,EAAK;AAAI,WAAA,KAAK,CAAC,KAAN,CAAY,WAAZ,EAA0B,GAA1B,CAAA,MAAA,CAAA;AAAqC,GAAzD,CAAlB,CAbkC,CAelC;;AACA,MAAM,YAAY,GAAG,SAAS,CAAC,CAAD,CAAT,CAAa,GAAb,CAAiB,UAAC,CAAD,EAAI,CAAJ,EAAK;AACzC,WAAA,SAAS,CAAC,GAAV,CAAc,UAAA,MAAA,EAAM;AAClB,MAAA,gBAAA,WAAA,CAAU,CAAC,IAAI,MAAf,EAAuB,gDAAvB;AACA,aAAO,MAAM,CAAC,CAAD,CAAb;AACD,KAHD,CAAA;AAGE,GAJiB,CAArB,CAhBkC,CAuBlC;;AACA,MAAM,aAAa,GAAG,YAAY,CAAC,GAAb,CAAiB,UAAA,MAAA,EAAM;AAC3C,WAAA,oBAAA,CAAA,kBAAA,CAAkB,QAAA,CAAA,EAAA,EAAM,MAAN,EAAY;AAAE,MAAA,MAAM,EAAA;AAAR,KAAZ,CAAlB,CAAA;AAAyC,GADrB,CAAtB,CAxBkC,CA4BlC;;AACA,SAAO,UAAC,KAAD,EAAc;AACnB,QAAI,CAAC,GAAG,CAAR;AACA,WAAO,MAAM,CAAC,CAAD,CAAN,CACJ,OADI,CACI,WADJ,EACiB,YAAA;AAAM,aAAA,MAAM,CAAC,aAAa,CAAC,CAAC,EAAF,CAAb,CAAP,KAAO,CAAD,CAAN;AAAiC,KADxD,EAEJ,OAFI,CAEI,SAFJ,EAEe,SAFf,CAAP;AAGD,GALD;AAMD,CApCY","sourcesContent":["import { createInterpolator } from './createInterpolator'\nimport { InterpolatorConfig } from './types/interpolation'\nimport { colorToRgba } from './colorToRgba'\nimport invariant from 'tiny-invariant'\nimport * as G from './globals'\n\n// Problem: https://github.com/animatedjs/animated/pull/102\n// Solution: https://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly/658662\nconst numberRegex = /[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g\n\n// Covers rgb, rgba, hsl, hsla\n// Taken from https://gist.github.com/olmokramer/82ccce673f86db7cda5e\nconst colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\\((-?\\d+%?[,\\s]+){2,3}\\s*[\\d\\.]+%?\\))/gi\n\n// Covers color names (transparent, blue, etc.)\nlet colorNamesRegex: RegExp\n\n// rgba requires that the r,g,b are integers.... so we want to round them,\n// but we *dont* want to round the opacity (4th column).\nconst rgbaRegex = /rgba\\(([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+)\\)/gi\nconst rgbaRound = (_: any, p1: number, p2: number, p3: number, p4: number) =>\n  `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`\n\n/**\n * Supports string shapes by extracting numbers so new values can be computed,\n * and recombines those values into new strings of the same shape.  Supports\n * things like:\n *\n *     \"rgba(123, 42, 99, 0.36)\"           // colors\n *     \"-45deg\"                            // values with units\n *     \"0 2px 2px 0px rgba(0, 0, 0, 0.12)\" // CSS box-shadows\n *     \"rotate(0deg) translate(2px, 3px)\"  // CSS transforms\n */\nexport const createStringInterpolator = (\n  config: InterpolatorConfig<string>\n) => {\n  if (!colorNamesRegex)\n    colorNamesRegex = G.colorNames\n      ? new RegExp(`(${Object.keys(G.colorNames).join('|')})`, 'g')\n      : /^\\b$/ // never match\n\n  // Convert colors to rgba(...)\n  const output = config.output.map(value =>\n    value.replace(colorRegex, colorToRgba).replace(colorNamesRegex, colorToRgba)\n  )\n\n  // Convert [\"1px 2px\", \"0px 0px\"] into [[1, 2], [0, 0]]\n  const keyframes = output.map(value => value.match(numberRegex)!.map(Number))\n\n  // Convert [\"1px 2px\", \"0px 0px\"] into [[1, 0], [2, 0]]\n  const outputRanges = keyframes[0].map((_, i) =>\n    keyframes.map(values => {\n      invariant(i in values, 'The arity of each \"output\" value must be equal')\n      return values[i]\n    })\n  )\n\n  // Create an interpolator for each animated number\n  const interpolators = outputRanges.map(output =>\n    createInterpolator({ ...config, output })\n  )\n\n  // Use the first `output` as a template for each call\n  return (input: number) => {\n    let i = 0\n    return output[0]\n      .replace(numberRegex, () => String(interpolators[i++](input)))\n      .replace(rgbaRegex, rgbaRound)\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}
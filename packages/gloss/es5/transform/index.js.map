{"version":3,"sources":["../../src/transform/index.js"],"names":["t","types","isIf","attribute","type","name","isntIf","x","jsxIfPlugin","node","path","attributes","openingElement","ifAttribute","filter","opening","JSXOpeningElement","tag","JSXElement","closingElement","children","conditional","conditionalExpression","value","expression","nullLiteral","replaceWith","classBodyVisitor","ClassMethod","state","GLOSS_ID","scope","generateUidIdentifier","hasJSX","post","stupidIsTag","tagName","toLowerCase","call","callExpression","stringLiteral","tagExpr","args","JSXNamespacedName","traverse","enter","opts","jsxIf","exit","body","unshift","variableDeclaration","variableDeclarator","identifier","programVisitor","Class","decorators","length","decoratorName","foundDecorator","some","item","callee","isMemberExpression","object","visitor","Program"],"mappings":"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","file":"index.js","sourcesContent":["import helper from 'babel-helper-builder-react-jsx'\n\nexport default function({ types: t }: { types: Object }) {\n  // convert React.createElement() => this.glossElement()\n\n  // todo this is horrible and lame\n  const isIf = attribute =>\n    attribute.type === 'JSXAttribute' && attribute.name.name === 'if'\n  const isntIf = x => !isIf(x)\n  const jsxIfPlugin = path => {\n    const { node } = path\n    const attributes = node.openingElement.attributes\n    if (!attributes) return\n    const ifAttribute = attributes.filter(isIf)[0]\n    if (ifAttribute) {\n      const opening = t.JSXOpeningElement(\n        node.openingElement.name,\n        attributes.filter(isntIf)\n      )\n      const tag = t.JSXElement(opening, node.closingElement, node.children)\n      const conditional = t.conditionalExpression(\n        ifAttribute.value.expression,\n        tag,\n        t.nullLiteral()\n      )\n      path.replaceWith(conditional)\n    }\n  }\n\n  const classBodyVisitor = {\n    ClassMethod(path: Object, state: Object) {\n      const GLOSS_ID = path.scope.generateUidIdentifier('gloss')\n      let hasJSX = false\n\n      const { JSXNamespacedName, JSXElement } = helper({\n        post(state) {\n          // need path to determine if variable or tag\n          const stupidIsTag =\n            state.tagName && state.tagName[0].toLowerCase() === state.tagName[0]\n\n          state.call = t.callExpression(GLOSS_ID, [\n            stupidIsTag ? t.stringLiteral(state.tagName) : state.tagExpr,\n            ...state.args,\n          ])\n        },\n      })\n\n      path.traverse(\n        {\n          JSXNamespacedName,\n          JSXElement: {\n            enter(...args) {\n              if (state.opts.jsxIf) {\n                jsxIfPlugin(...args)\n              }\n              hasJSX = true\n            },\n            exit: JSXElement.exit,\n          },\n        },\n        state\n      )\n\n      if (hasJSX) {\n        // add a fancyelement hook to start of render\n        path.node.body.body.unshift(\n          t.variableDeclaration('const', [\n            t.variableDeclarator(\n              GLOSS_ID,\n              t.identifier('this.glossElement.bind(this)')\n            ),\n          ])\n        )\n      }\n    },\n  }\n\n  const programVisitor = {\n    Class(path: Object, state: Object) {\n      const node = path.node\n\n      if (!node.decorators || !node.decorators.length) {\n        return\n      }\n\n      // -- Validate if class is what we're looking for\n      //    has some flexibility, looks for any of:\n      //       @x  @x()  @x.y  @x.y()\n\n      const decoratorName = (state.opts && state.opts.decoratorName) || 'style'\n\n      const foundDecorator = node.decorators.some(item => {\n        if (!item.expression) {\n          return false\n        }\n        // @style\n        if (\n          item.expression.type === 'Identifier' &&\n          item.expression.name === decoratorName\n        ) {\n          return true\n        }\n        // @style()\n        if (\n          item.expression.callee &&\n          item.expression.callee.name === decoratorName\n        ) {\n          return true\n        }\n        // @style.something()\n        if (\n          item.expression.callee &&\n          t.isMemberExpression(item.expression.callee) &&\n          item.expression.callee.object.name === decoratorName\n        ) {\n          return true\n        }\n        // @style.something\n        if (\n          item.expression.object &&\n          item.expression.object.name === decoratorName\n        ) {\n          return true\n        }\n\n        return false\n      })\n\n      // -- Add a unique var to scope and all of JSX elements\n      if (foundDecorator) {\n        path.traverse(classBodyVisitor, state)\n      }\n    },\n  }\n\n  return {\n    visitor: {\n      Program(path: Object, state: Object) {\n        path.traverse(programVisitor, state)\n      },\n    },\n  }\n}\n"]}
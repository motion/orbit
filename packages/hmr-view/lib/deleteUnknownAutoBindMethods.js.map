{"version":3,"sources":["../src/deleteUnknownAutoBindMethods.js"],"names":["deleteUnknownAutoBindMethods","shouldDeleteClassicInstanceMethod","component","name","__reactAutoBindMap","hasOwnProperty","__reactAutoBindPairs","indexOf","__reactBoundArguments","shouldDeleteModernInstanceMethod","prototype","constructor","prototypeDescriptor","Object","getOwnPropertyDescriptor","get","length","shouldDeleteInstanceMethod","descriptor","value","names","getOwnPropertyNames","forEach"],"mappings":";;;;;kBAyEwBA,4B;AAzExB,SAASC,iCAAT,CAA2CC,SAA3C,EAAsDC,IAAtD,EAA4D;AAC1D,MACED,UAAUE,kBAAV,IACAF,UAAUE,kBAAV,CAA6BC,cAA7B,CAA4CF,IAA5C,CAFF,EAGE;AACA;AACA,WAAO,KAAP;AACD;;AAED,MACED,UAAUI,oBAAV,IACAJ,UAAUI,oBAAV,CAA+BC,OAA/B,CAAuCJ,IAAvC,KAAgD,CAFlD,EAGE;AACA;AACA,WAAO,KAAP;AACD;;AAED,MAAID,UAAUC,IAAV,EAAgBK,qBAAhB,KAA0C,IAA9C,EAAoD;AAClD;AACA,WAAO,KAAP;AACD;;AAED;AACA;AACA,SAAO,IAAP;AACD;;AAED,SAASC,gCAAT,CAA0CP,SAA1C,EAAqDC,IAArD,EAA2D;AAAA,MACjDO,SADiD,GACnCR,UAAUS,WADyB,CACjDD,SADiD;;AAEzD,MAAME,sBAAsBC,OAAOC,wBAAP,CAAgCJ,SAAhC,EAA2CP,IAA3C,CAA5B;;AAEA,MAAI,CAACS,mBAAD,IAAwB,CAACA,oBAAoBG,GAAjD,EAAsD;AACpD;AACA,WAAO,KAAP;AACD;;AAED,MAAIH,oBAAoBG,GAApB,GAA0BC,MAA1B,KAAqCd,UAAUC,IAAV,EAAgBa,MAAzD,EAAiE;AAC/D;AACA,WAAO,KAAP;AACD;;AAED;AACA;AACA,SAAO,IAAP;AACD;;AAED,SAASC,0BAAT,CAAoCf,SAApC,EAA+CC,IAA/C,EAAqD;AACnD,MAAMe,aAAaL,OAAOC,wBAAP,CAAgCZ,SAAhC,EAA2CC,IAA3C,CAAnB;AACA,MAAI,OAAOe,WAAWC,KAAlB,KAA4B,UAAhC,EAA4C;AAC1C;AACA;AACD;;AAED,MAAIjB,UAAUE,kBAAV,IAAgCF,UAAUI,oBAA9C,EAAoE;AAClE;AACA,WAAOL,kCAAkCC,SAAlC,EAA6CC,IAA7C,CAAP;AACD,GAHD,MAGO;AACL;AACA,WAAOM,iCAAiCP,SAAjC,EAA4CC,IAA5C,CAAP;AACD;AACF;;AAED;;;;;;;;;;;AAWe,SAASH,4BAAT,CAAsCE,SAAtC,EAAiD;AAC9D,MAAMkB,QAAQP,OAAOQ,mBAAP,CAA2BnB,SAA3B,CAAd;;AAEAkB,QAAME,OAAN,CAAc,gBAAQ;AACpB,QAAIL,2BAA2Bf,SAA3B,EAAsCC,IAAtC,CAAJ,EAAiD;AAC/C,aAAOD,UAAUC,IAAV,CAAP;AACD;AACF,GAJD;AAKD","file":"deleteUnknownAutoBindMethods.js","sourcesContent":["function shouldDeleteClassicInstanceMethod(component, name) {\n  if (\n    component.__reactAutoBindMap &&\n    component.__reactAutoBindMap.hasOwnProperty(name)\n  ) {\n    // It's a known autobound function, keep it\n    return false\n  }\n\n  if (\n    component.__reactAutoBindPairs &&\n    component.__reactAutoBindPairs.indexOf(name) >= 0\n  ) {\n    // It's a known autobound function, keep it\n    return false\n  }\n\n  if (component[name].__reactBoundArguments !== null) {\n    // It's a function bound to specific args, keep it\n    return false\n  }\n\n  // It's a cached bound method for a function\n  // that was deleted by user, so we delete it from component.\n  return true\n}\n\nfunction shouldDeleteModernInstanceMethod(component, name) {\n  const { prototype } = component.constructor\n  const prototypeDescriptor = Object.getOwnPropertyDescriptor(prototype, name)\n\n  if (!prototypeDescriptor || !prototypeDescriptor.get) {\n    // This is definitely not an autobinding getter\n    return false\n  }\n\n  if (prototypeDescriptor.get().length !== component[name].length) {\n    // The length doesn't match, bail out\n    return false\n  }\n\n  // This seems like a method bound using an autobinding getter on the prototype\n  // Hopefully we won't run into too many false positives.\n  return true\n}\n\nfunction shouldDeleteInstanceMethod(component, name) {\n  const descriptor = Object.getOwnPropertyDescriptor(component, name)\n  if (typeof descriptor.value !== 'function') {\n    // Not a function, or something fancy: bail out\n    return\n  }\n\n  if (component.__reactAutoBindMap || component.__reactAutoBindPairs) {\n    // Classic\n    return shouldDeleteClassicInstanceMethod(component, name)\n  } else {\n    // Modern\n    return shouldDeleteModernInstanceMethod(component, name)\n  }\n}\n\n/**\n * Deletes autobound methods from the instance.\n *\n * For classic React classes, we only delete the methods that no longer exist in map.\n * This means the user actually deleted them in code.\n *\n * For modern classes, we delete methods that exist on prototype with the same length,\n * and which have getters on prototype, but are normal values on the instance.\n * This is usually an indication that an autobinding decorator is being used,\n * and the getter will re-generate the memoized handler on next access.\n */\nexport default function deleteUnknownAutoBindMethods(component) {\n  const names = Object.getOwnPropertyNames(component)\n\n  names.forEach(name => {\n    if (shouldDeleteInstanceMethod(component, name)) {\n      delete component[name]\n    }\n  })\n}\n"]}
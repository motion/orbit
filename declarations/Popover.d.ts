import { Color } from '@mcro/css';
import { Cancelable } from 'lodash';
import * as React from 'react';
import { SurfaceProps } from './Surface';
export declare type PopoverProps = SurfaceProps & {
    themeName?: string;
    group?: string;
    children?: React.ReactNode | PopoverChildrenFn;
    target?: React.ReactNode | (() => React.ReactNode) | string;
    open?: boolean;
    forgiveness?: number;
    overlay?: boolean;
    left?: number;
    top?: number;
    distance?: number;
    openOnClick?: boolean;
    openOnHover?: boolean;
    delay?: number;
    noHoverOnChildren?: boolean;
    arrowSize?: number;
    closeOnClickAway?: boolean;
    closeOnClick?: boolean;
    closeOnEsc?: boolean;
    towards?: PopoverDirection;
    alignPopover?: 'left' | 'center';
    padding?: number[] | number;
    onMouseEnter?: Function;
    onMouseLeave?: Function;
    onClose?: Function;
    openAnimation?: string;
    closeAnimation?: string;
    adjust?: number[];
    noArrow?: boolean;
    edgePadding?: number;
    keepOpenOnClickTarget?: boolean;
    onDidClose?: Function;
    onDidOpen?: Function;
    onOpen?: Function;
    height?: number;
    width?: number;
    background?: true | Color;
    passActive?: boolean;
    popoverProps?: Object;
    style?: Object;
    elevation?: number;
    ignoreSegment?: boolean;
    onChangeVisibility?: (visibility: boolean) => any;
    noPortal?: boolean;
    showForgiveness?: boolean;
    popoverRef?: Function;
};
declare const defaultProps: {
    edgePadding: number;
    distance: number;
    arrowSize: number;
    forgiveness: number;
    towards: string;
    transition: string;
    openAnimation: string;
    closeAnimation: string;
    adjust: number[];
    delay: number;
};
declare type PopoverPropsWithDefaults = PopoverProps & typeof defaultProps;
declare type DebouncedFn = Cancelable & (() => void);
declare type PopoverDirection = 'top' | 'bottom' | 'left' | 'right' | 'auto';
export declare const PopoverState: {
    openPopovers: Set<any>;
    closeLast: () => void;
    closeAll: () => void;
};
export declare type PopoverChildrenFn = ((showPopover: boolean) => React.ReactNode);
declare const initialState: {
    maxHeight: any;
    targetBounds: any;
    popoverBounds: any;
    showPopover: boolean;
    targetHovered: number;
    menuHovered: number;
    top: number;
    left: number;
    arrowTop: number;
    arrowLeft: number;
    arrowInnerTop: number;
    isPinnedOpen: number;
    direction: PopoverDirection;
    delay: number;
    props: PopoverProps;
    closing: boolean;
    measureState: "done" | "measured" | "shouldMeasure";
};
declare type State = typeof initialState & {
    targetBounds: any;
    popoverBounds: any;
    maxHeight: any;
};
export declare class Popover extends React.PureComponent<PopoverProps, State> {
    static acceptsHovered: string;
    static defaultProps: {
        edgePadding: number;
        distance: number;
        arrowSize: number;
        forgiveness: number;
        towards: string;
        transition: string;
        openAnimation: string;
        closeAnimation: string;
        adjust: number[];
        delay: number;
    };
    targetRef: React.RefObject<HTMLDivElement>;
    target: HTMLElement;
    popoverRef: HTMLElement;
    state: {
        maxHeight: any;
        targetBounds: any;
        popoverBounds: any;
        showPopover: boolean;
        targetHovered: number;
        menuHovered: number;
        top: number;
        left: number;
        arrowTop: number;
        arrowLeft: number;
        arrowInnerTop: number;
        isPinnedOpen: number;
        direction: PopoverDirection;
        delay: number;
        props: PopoverProps;
        closing: boolean;
        measureState: "done" | "measured" | "shouldMeasure";
    };
    static getDerivedStateFromProps(props: PopoverPropsWithDefaults, state: State): Partial<State>;
    setPopoverRef: (ref: HTMLElement) => void;
    readonly domNode: HTMLDivElement;
    componentDidMount(): void;
    unmounted: boolean;
    componentWillUnmount(): void;
    componentDidUpdate(_prevProps: any, prevState: any): void;
    setPosition: (afterMeasure?: () => any) => void;
    forceClose: () => Promise<void>;
    toggleOpen: () => void;
    open: () => void;
    startClosing: () => Promise<{}>;
    close: () => Promise<void>;
    targetClickOff: any;
    listenForClick: () => void;
    readonly wasJustClicked: boolean;
    listenForClickAway(): void;
    private stopListeningUntilNextMouseEnter;
    clearHovered(): Promise<{}>;
    readonly isHovered: number;
    handleOverlayClick(event: any): void;
    listeners: any[];
    listenForHover(): void;
    removeListeners(): void;
    delayOpenIfHover: {
        [key: string]: DebouncedFn | null;
    };
    private cancelIfWillOpen;
    addHoverListeners(name: string, node: HTMLElement): any;
    hoverStateSet(name: any, isHovered: any): any;
    isNodeHovered: (node: HTMLElement) => Element;
    overlayRef: (ref: any) => void;
    handleTargetClick: () => void;
    controlledTarget: (target: any) => JSX.Element;
    closeOthersWithinGroup(): void;
    readonly isMeasuring: boolean;
    readonly showPopover: boolean;
    render(): JSX.Element;
}
export {};
//# sourceMappingURL=Popover.d.ts.map
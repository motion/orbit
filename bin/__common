#!/bin/bash

# break on errors
set -e

APP_OLD_PWD="$(pwd)"
OLD_PATH=$PATH

# source env
source .env

# set path/root
PATH=/usr/local/bin:/usr/bin
ROOT="$(pwd)"

# add node_modules
PATH=$OLD_PATH:$ROOT/node_modules/.bin

# cd back to original dir
cd $APP_OLD_PWD

# run with echo
function run {
  echo "$" "$@"
  eval $(printf '%q ' "$@") < /dev/tty
}

function parse-config {
  envtpl $1 -o ./app_data/tmpconf --keep-template
  cat ./app_data/tmpconf
}

# get kubes config
function save-config {
  rm -rf $KUBES_CONFIG_OUT
  mkdir -p $KUBES_CONFIG_OUT

  ALL=""

  for path in ./infra/kubes/*; do
    OUT="$KUBES_CONFIG_OUT/$(basename $path .yml).yml"
    parse-config $path > $OUT
    ALL+=$(parse-config $path)
    ALL+=$'\n'
  done

  # add in extra env configs
  dir=./infra/kubes.$ENV
  if [ -d $dir ]; then
    for path in $dir/*; do
      OUT="$KUBES_CONFIG_OUT/$(basename $path .yml).yml"
      parse-config $path > $OUT
      ALL+=$(parse-config $path)
      ALL+=$'\n'
    done
  fi

  echo "$ALL" > "$KUBES_CONFIG_FILE"
}

function link-flow() {
  OG=$(pwd)
  cd $ROOT
  # link flow
  find . -name *.js.flow | grep -v node_modules | xargs rm -f

  function link() {
    for PACKAGE in $(ls $1); do
      if [ ! -d "$ROOT/$1/$PACKAGE/src" ]; then
        continue
      fi
      cd $ROOT/$1/$PACKAGE
      mkdir -p lib

      ENTRIES=$(cd src; find . -name "*.js")
      for ENTRY in $ENTRIES; do
        ENTRY_TRIMMED=${ENTRY:2}
        mkdir -p lib/$(dirname $ENTRY_TRIMMED)
        ln src/$ENTRY_TRIMMED lib/$ENTRY_TRIMMED.flow
      done

      cd -
      echo "Linked $PACKAGE"
    done
  }

  # link flow in all
  link "packages"
  link "apps"
  cd $OG
}

function bin-exists {
  echo "$(which $1 2> /dev/null)"
}

function file-exists {
  if [ ! -f "$1" ]; then
    echo "$2 not found"
    exit 1
  fi
}

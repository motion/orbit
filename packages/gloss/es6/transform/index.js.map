{"version":3,"sources":["../../src/transform/index.js"],"names":["types","t","isIf","attribute","type","name","isntIf","x","jsxIfPlugin","path","node","attributes","openingElement","ifAttribute","filter","opening","JSXOpeningElement","tag","JSXElement","closingElement","children","conditional","conditionalExpression","value","expression","nullLiteral","replaceWith","classBodyVisitor","ClassMethod","state","GLOSS_ID","scope","generateUidIdentifier","hasJSX","JSXNamespacedName","post","stupidIsTag","tagName","toLowerCase","call","callExpression","stringLiteral","tagExpr","args","traverse","enter","opts","jsxIf","exit","body","unshift","variableDeclaration","variableDeclarator","identifier","programVisitor","Class","decorators","length","decoratorName","foundDecorator","some","item","callee","isMemberExpression","object","visitor","Program"],"mappings":"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","file":"index.js","sourcesContent":["// @flow\nimport helper from 'babel-helper-builder-react-jsx'\n\nexport default function({ types: t }: { types: Object }) {\n  // convert React.createElement() => this.glossElement()\n\n  // todo this is horrible and lame\n  const isIf = attribute =>\n    attribute.type === 'JSXAttribute' && attribute.name.name === 'if'\n  const isntIf = x => !isIf(x)\n  const jsxIfPlugin = path => {\n    const { node } = path\n    const attributes = node.openingElement.attributes\n    if (!attributes) return\n    const ifAttribute = attributes.filter(isIf)[0]\n    if (ifAttribute) {\n      const opening = t.JSXOpeningElement(\n        node.openingElement.name,\n        attributes.filter(isntIf)\n      )\n      const tag = t.JSXElement(opening, node.closingElement, node.children)\n      const conditional = t.conditionalExpression(\n        ifAttribute.value.expression,\n        tag,\n        t.nullLiteral()\n      )\n      path.replaceWith(conditional)\n    }\n  }\n\n  const classBodyVisitor = {\n    ClassMethod(path: Object, state: Object) {\n      const GLOSS_ID = path.scope.generateUidIdentifier('gloss')\n      let hasJSX = false\n\n      const { JSXNamespacedName, JSXElement } = helper({\n        post(state) {\n          // need path to determine if variable or tag\n          const stupidIsTag =\n            state.tagName && state.tagName[0].toLowerCase() === state.tagName[0]\n\n          state.call = t.callExpression(GLOSS_ID, [\n            stupidIsTag ? t.stringLiteral(state.tagName) : state.tagExpr,\n            ...state.args,\n          ])\n        },\n      })\n\n      path.traverse(\n        {\n          JSXNamespacedName,\n          JSXElement: {\n            enter(path) {\n              if (state.opts.jsxIf) {\n                jsxIfPlugin(path)\n              }\n              hasJSX = true\n            },\n            exit: JSXElement.exit,\n          },\n        },\n        state\n      )\n\n      if (hasJSX) {\n        // add a fancyelement hook to start of render\n        path.node.body.body.unshift(\n          t.variableDeclaration('const', [\n            t.variableDeclarator(\n              GLOSS_ID,\n              t.identifier('this.glossElement.bind(this)')\n            ),\n          ])\n        )\n      }\n    },\n  }\n\n  const programVisitor = {\n    Class(path: Object, state: Object) {\n      const node = path.node\n\n      if (!node.decorators || !node.decorators.length) {\n        return\n      }\n\n      // -- Validate if class is what we're looking for\n      //    has some flexibility, looks for any of:\n      //       @x  @x()  @x.y  @x.y()\n\n      const decoratorName = (state.opts && state.opts.decoratorName) || 'style'\n\n      const foundDecorator = node.decorators.some(item => {\n        if (!item.expression) {\n          return false\n        }\n        // @style\n        if (\n          item.expression.type === 'Identifier' &&\n          item.expression.name === decoratorName\n        ) {\n          return true\n        }\n        // @style()\n        if (\n          item.expression.callee &&\n          item.expression.callee.name === decoratorName\n        ) {\n          return true\n        }\n        // @style.something()\n        if (\n          item.expression.callee &&\n          t.isMemberExpression(item.expression.callee) &&\n          item.expression.callee.object.name === decoratorName\n        ) {\n          return true\n        }\n        // @style.something\n        if (\n          item.expression.object &&\n          item.expression.object.name === decoratorName\n        ) {\n          return true\n        }\n\n        return false\n      })\n\n      // -- Add a unique var to scope and all of JSX elements\n      if (foundDecorator) {\n        path.traverse(classBodyVisitor, state)\n      }\n    },\n  }\n\n  return {\n    visitor: {\n      Program(path: Object, state: Object) {\n        path.traverse(programVisitor, state)\n      },\n      JSXElement(path, state) {\n        if (state.opts.jsxIf) {\n          jsxIfPlugin(path)\n        }\n      },\n    },\n  }\n}\n"]}